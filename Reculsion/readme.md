#Reculsion
<pre>
ex) int func1 (int n) {<br>
    if (n==1) return 1;<br>
    else return n+func1(n-1);<br>
}</pre>
<br>
위 함수를 해석하는 데에는 1) 절차지향적 사고 2)귀납적 사고 2가지의 방법이 존재한다.
1) 절차지향적 사고
    func(3) -> 3+func(2) -> 3+2+func(1) -> 3+2+1+func(0) = 3+2+1+0 -> func(k)는 1~k의 합
2) 귀납적 사고
    func(1)은 1을 return한다. -> func(k)가 1부터 k까지의 합을 return한다고 가정한다 -> func(k+1)은 func(k)+(k+1)을 반환한다. -> func(k)는 1부터 k까지의 합
    
  올바른 재귀 함수는 반드시 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어아 한다. 이러한 입력을 base condition 또는 base case라고 한다. 
또한 모든 입력은 결국 base condition으로 수렴해야 한다. 위 코드의 경우, n=1인 경우에 자기 자신을 호출하지 않고 종료가 되니 이것이 base condition이고 우리는 이 함수에 자연수만 넣을테니 결국 모든 입력은 n=1으로 수렵하게 된다. 위 두개의 조건을 반드시 만족하여야 한다.
<br>
  재귀 함수에서는 함수를 명확하게 정의해야 한다. 함수의 인자로 어떤 것을 받을 것인지, 그리고 어디까지 계산한 후 자기 자신에게 넘겨줄지를 의미한다. 또한 모든 재귀 함수는 재귀 구조 없이 반복문만으로 동일한 동작을 하는 함수를 만들 수 있다. 
<br>
  재귀 함수는 자기 자신을 여러 번 호출하게 되는데, 이렇게 되면 생각보다 되게 비효율적일 수 있다. 예를 들어 fibo(5)의 값을 계산하기 위해서 이미 사용하였던 fibo(3)의 값을 2번 호출하는 등의 단점이 존재한다. 따라서 반복문으로 구현이 가능할 때는 반복문을 사용하여서 구현하는 것이 오히려 시간 복잡도 면에서 우위를 점하는 경우가 있다. 또한 fibo와 같이 이전에 사용한 값을 다시 사용해야 할때는 굳이 재귀를 사용하지 않고 일전에 공부하였던 DP를 사용한다면 훨씬 유리하다.
<br>
